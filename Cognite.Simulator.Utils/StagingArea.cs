using Cognite.Extractor.Common;
using Cognite.Extractor.Utils;
using CogniteSdk;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

namespace Cognite.Simulator.Utils
{
    /// <summary>
    /// This class represents a staging area for storing simulator related
    /// data in CDF. This is to be used for information outside the main 
    /// simulation data generated by connectors. Often the staged data is stored
    /// in CDF Raw and has to be parsed by an external process to be useful
    /// </summary>
    public class StagingArea<T> where T : StagingData
    {
        private readonly CogniteDestination _cdf;
        private readonly StagingConfig _config;
        private readonly CogniteConfig _cdfConfig;
        private readonly ILogger<StagingArea<T>> _logger;
        public bool HasRawCapabilities { get; private set; }
        private bool _initialized = false;

        public StagingArea(
            CogniteDestination cdf,
            StagingConfig config,
            CogniteConfig cdfConfig,
            ILogger<StagingArea<T>> logger)
        {
            _cdf = cdf;
            _config = config;
            _cdfConfig = cdfConfig;
            _logger = logger;
        }

        public async Task UpdateEntry(
            string modelExternalId,
            T info,
            CancellationToken token)
        {
            if (!_config.Enabled)
            {
                return;
            }
            if (!_initialized)
            {
                await Init(token);
            }
            if (!HasRawCapabilities)
            {
                return;
            }

            info.LastUpdatedTime = DateTime.UtcNow.ToUnixTimeMilliseconds();
            await _cdf.CogniteClient.Raw.CreateRowsAsync(
                _config.Database,
                _config.Table,
                new List<RawRowCreate<T>>()
                {
                        new RawRowCreate<T>
                        {
                            Key = modelExternalId,
                            Columns = info
                        }
                },
                ensureParent: true,
                token: token).ConfigureAwait(false);
        }
    
        private async Task Init(CancellationToken token)
        {
            try
            {
                var inspect = await _cdf.CogniteClient.Token.InspectAsync(token);
                var capabilities = inspect.Capabilities.ToList();
                var hasCapabilities = capabilities
                    .Where(c => c is RawAcl && c.All != null && c.ProjectsScope.Contains(_cdfConfig.Project))
                    .Where(c => c.Actions.Contains("READ") && c.Actions.Contains("LIST") && c.Actions.Contains("WRITE"))
                    .Any();
                if (hasCapabilities && _config.Enabled)
                {
                    await InitRawDatabase(token);
                    HasRawCapabilities = true;
                }

                if (!hasCapabilities)
                {
                    _logger.LogError("Capabilities required by the connector are missing: rawAcl:READ, rawAcl:WRITE and rawAcl:LIST");
                }
            }
            catch (Exception e)
            {
                _logger.LogError(e, "Failed to inspect CDF capabilities. Requires projectsAcl:LIST and groupsAcl:LIST");
            }
            _initialized = true;
        }

        private async Task InitRawDatabase(
            CancellationToken token)
        {
            try
            {
                await _cdf.CogniteClient.Raw.CreateTablesAsync(
                    _config.Database,
                    new List<RawTable>()
                    {
                        new RawTable
                        {
                            Name = _config.Table
                        }
                    }, 
                    true, // Ensure database exists
                    token).ConfigureAwait(false);
            }
            catch (ResponseException ex) when (ex.Code == 400 && ex.Message.Contains("already created"))
            {
                _logger.LogDebug("Raw table already exists: {Name}", _config.Table);
            }
        }

        public async Task<T> GetEntry(
            string key,
            CancellationToken token)
        {
            try
            {
                RawRow<T> row =  await _cdf.CogniteClient.Raw
                    .GetRowAsync<T>(_config.Database, _config.Table, key, token: token)
                    .ConfigureAwait(false);
                return row.Columns;
            }
            catch (ResponseException re) when (re.Code == 404)
            {
                return default;
            }
            catch (Exception e)
            {
                _logger.LogError("Could not fecth data from CDF RAW", e);
                return default;
            }
        }
    }

    public class StagingData
    {
        public long LastUpdatedTime { get; set; }
    }

    public class ModelParsingInfo : StagingData
    {
        public string ModelName { get; set; }
        public string Simulator { get; set; }
        public int ModelVersion { get; set; }
        [JsonConverter(typeof(JsonStringEnumConverter))]
        public ParsingStatus Status { get; set; }
        public bool Parsed { get; set; }
        public bool Error { get; set; }
        public List<ParsingLog> Log { get; set; } = new List<ParsingLog>();
    }
    
    public enum ParsingStatus
    {
        ready,
        running,
        retrying,
        success,
        failure
    }

    public class ParsingLog
    {
        public ParsingLog(ParsingLogLevel level, string message)
        {
            Level = level;
            Message = message;
        }

        [JsonConverter(typeof(JsonStringEnumConverter))]
        public ParsingLogLevel Level { get; set; }
        public string Message { get; set; }

    }

    public enum ParsingLogLevel
    {
        INFORMATION,
        WARNING,
        ERROR
    }

    public static class ModelParsingExtensions
    {
        public static void AddInfo(this ModelParsingInfo mpi, string message)
        {
            mpi.Add(ParsingLogLevel.INFORMATION, message);
        }

        public static void AddWarning(this ModelParsingInfo mpi, string message)
        {
            mpi.Add(ParsingLogLevel.WARNING, message);
        }

        public static void AddError(this ModelParsingInfo mpi, string message)
        {
            mpi.Add(ParsingLogLevel.ERROR, message);
        }

        public static void SetSuccess(this ModelParsingInfo mpi, string message = null)
        {
            mpi.SetStatus(ParsingStatus.success, true, false, ParsingLogLevel.INFORMATION, message);
        }

        public static void SetRetrying(this ModelParsingInfo mpi, string message = null)
        {
            mpi.SetStatus(ParsingStatus.retrying, false, true, ParsingLogLevel.WARNING, message);
        }

        public static void SetFailure(this ModelParsingInfo mpi, string message = null)
        {
            mpi.SetStatus(ParsingStatus.failure, true, true, ParsingLogLevel.ERROR, message);
        }

        private static void SetStatus(this ModelParsingInfo mpi, ParsingStatus status, bool isParsed, bool isError, ParsingLogLevel level, string message = null)
        {
            mpi.Status = status;
            mpi.Parsed = isParsed;
            mpi.Error = isError;
            if (!string.IsNullOrEmpty(message))
            {
                mpi.Add(level, message);
            }
        }

        private static void Add(this ModelParsingInfo mpi, ParsingLogLevel level, string message)
        {
            mpi.Log.Add(
                new ParsingLog(
                    level,
                    message));
        }
    }

    public static class StagingAreaExtensions
    {
        public static void AddStagingArea<T>(this IServiceCollection services, StagingConfig config) where T : StagingData
        {
            services.AddSingleton<StagingConfig>(config);
            services.AddScoped<StagingArea<T>>();
        }
    }
}
